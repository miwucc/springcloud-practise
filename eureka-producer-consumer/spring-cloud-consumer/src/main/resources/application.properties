spring.application.name=spring-cloud-consumer
server.port=9001
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/

#启动后访问http://localhost:9001/hello/myname 尝试进行远程调用


###作为服务注册到注册中心，默认true
#eureka.client.register-with-eureka=true
##作为客户端拉取服务列表,默认true
#eureka.client.fetch-registry=true
#每次拉取服务列表后等待多少秒再拉取最新的，默认30s
eureka.client.registry-fetch-interval-seconds=30


# 自动配置总入口类: RibbonAutoConfiguration,具体的整个启动过程可以参考文章：https://blog.csdn.net/qq_27529917/article/details/80981109
# RibbonAutoConfiguration中有@RibbonClients注解默认引入了Ribbon客户端注册类@Import({RibbonClientConfigurationRegistrar.class})
# 这儿默认注册了配置List<RibbonClientSpecification> configurations,并用来初始化clientFactory这个RibbonClient信息工厂
# @RibbonClients注解用来指定了ribbon的配置类,也可以指定用于哪一个服务名，否则将对所有未指定服务名的生效
# 然后SpringClientfactory在使用getInsance的时候，会去找当前serverID对应的容器，如果容器会不存在则创建该该容器并把对应的configration注册到对应的容器中实例化该容器的bean(配置的对应服务名字的loadBanlancer,IRule这些)
# 参看或者打断点看：NameConextedFactory.createContext(String name)
# 这样在每次getLoadBalance(ServiceId(服务名))的时候，就可以从对应的服务的namedFactory对应的容器中找到如下配置的这些实例对象用于负债均衡等等操作:
#
#
# 主要的Ribbon配置接口如下:
# IClientConfig ribbon客户端配置默认采用DefaultClientConfigImpl
# ILoadBalancer  负载均衡器，默认采用ZoneAvoidanceRule，能在多区环境下选出最佳区域实例进行访问
# IPing   ribbon实例的loadbalancer检查策略所用类，默认使用NoOpPing，默认所有实例可用
# IRule Ribbon的loadbalancer负载均衡策略所用类，默认采用ZoneAvoidanceRule,可在多区环境下选出最佳区域实例进行访问
# ServerList<Server>  服务实例清单维护机制，默认采用ConfigurationBasedServerList、就是直接配置一个服务器列表
# ServerListerFilter<Server> 服务实例清单过滤机制，默认采用ZonePreferenceserverlistFilter ,可以优选过滤出与请求调用方同区域的服务实例
# 可以通过在properties中<clientName(服务名)>.ribbon.<key>=<value> 对上面说的几个参数进行类设置，具体key名字请参考PropertiesFactory，这个是在EurekaRibbonClientConfiguration配置的时候会先去找PropertiesFactory相应的key是否已设值
# 这个主要是用来定制化实现RibbonClient，这里指的客户端指的是 LoadBanlanceClient(RibbonLoadBalancerClient)->clientFactory中的cilent,和reueka结合起来用的时候clientId就是服务名
# 下面是其他全局和只指定客户端配置
#  全局：ribbon.<key>=<value> 例如： ribbon.ConnectTImeout=250
#  制定客户端：
# <clientName(服务名)>.ribbon.<key>=<value>
# 具体可以配置那些参数请参考：CommonClientConfigKey
#
# Ribbon只是一个纯粹的负债均衡框架组件，当他和eurekaClient联合起来使用的时候，eureka会把以上的
#  ServerList<Server> 替换为 DiscoveryEnabledNOWSServerList,把服务清单列表叫给eureka服务治理机制来维护，
#  IPing 替换为 NIWSDiscoveryPing
#  clientId会变为eureka的服务名
#
# 服务调用不通的时候使用的容错retry机制，默认是打开的 LoadBalancerRetryProperties这个类可以看到相关配置
#spring.cloud.loadbalancer.retry.enabled=true

#
#<spring-cloud-producer服务名>.ribbon.ConnectTimeout=250 连接超时时间
#<spring-cloud-producer服务名>.ribbon.ReadTimeout=1000 请求处理超时时间
#<spring-cloud-producer服务名>.ribbon.OkToRetryOnAllOperations=true 意义是无论是请求超时或者socket read timeout都进行重试，
#<spring-cloud-producer服务名>.ribbon.MaxAutoRetriesNextServer=2 重试的时候切换实例重试最大次数，不包含一开始这个实例，这里配置2意思是可以切换到2个新的实例尝试
#<spring-cloud-producer服务名>.ribbon.MaxAutoRetries=1 对当前实例的最大重试次数
# 如上所示代表遇到访问故障的时候会进行重试,先对当前实例默认重试MaxAutoRetries次，如果不行，则切换实例，最大切换MaxAutoRetriesNextServer次还失败则返回失败
# ！！！！这里有坑注意！！ 注意开了重试的时候，对于写操作，可能会前后发起多次请求，比如ReadTimeout导致的，从而导致一个多次写入，需要在服务提供端自己做好幂等性处理
# 建议OkToRetryOnAllOperations设置为false，或者写操作关闭， 请看分析：https://www.cnblogs.com/zhangjianbin/p/7228628.html
# 更多ribbon配置也可以参考ribbon的github



