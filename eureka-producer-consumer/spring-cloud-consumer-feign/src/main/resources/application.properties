spring.application.name=spring-cloud-consumer-feign-hystrixserver.port=9111server.tomcat.min-spare-threads=100server.tomcat.max-threads=100#feign默认会把申明的接口加入断路器管理，但是默认开启时false，需要打开设置为true#feign的情况下全局打开关闭Hystrix，配置类FeignClientsConfiguration.HystrixFeignConfiguration.feignHystrixBuilder#如果开启了sentinel的情况下，会抢先生成Feign.Builder，导致上面的自动配置条件失效，从而hystrix失效，只能用sentinelfeign.hystrix.enabled=true#需要用actuator观察断路器状态的时候，需要再单独打开下面这个注解，启动类还要加上注解@EnableCircuitBreakerspring.cloud.circuit.breaker.enabled=true#开启feign对sentinel的支持,当时用了ali的openfeign后，原来的hystrix不会再生效了#资源名默认定义  httpmethod:protocol://requesturl 例子#public interface EchoService {#@RequestMapping(value = "/echo/{str}", method = RequestMethod.GET)#String echo(@PathVariable("str") String str);#}# GET:http://service-provider/echo/{str}feign.sentinel.enabled=true#开启http线程池来对后端机进行调用 org.springframework.cloud.netflix.feign.ribbon.HttpClientFeignLoadBalancedConfiguration里面有配置逻辑#默认是使用feign.Client.Defaultfeign.httpclient.enabled=true#feign.okhttp.enabled=true OkHttp 和 httpclient任意选一个，两个做的事情都是一样的。配置入口OkHttpFeignLoadBalancedConfiguration#-----------------------------feign gzip支持，request是指为请求的数据压缩并加上gzipheader# 必须要有ApacheHttpClient Bean才会生效,查看类FeignAcceptGzipEncodingAutoConfiguration,FeignContentGzipEncodingAutoConfiguration# 浏览器 <---- (tomcat gzip压缩)consumer(feign gzip解压) <-- (tomcat gzip压缩)producer# 浏览器 ----> consumer(feign gzip压缩) --> (tomcat gzip解压)producer#下面这个配置，当feign和ribbon一起使用，只要你引入了ribbon包，其实下面的配置都不能生效，不信看源码！#FeignRibbonClientAutoConfiguration会先于FeignAutoConfiguration进行配置#这个时候生成的是LoadBalancerFeignClient而不是ApacheHttpClient，上面FeignAcceptGzipEncodingAutoConfiguration，FeignContentGzipEncodingAutoConfiguration必须要@ConditionalOnBean(ApacheHttpClient.class)才生效#所以，其实下面这个配置没有任何用，我也试了，就算不生效，顶多就是不能对requst请求数据压缩后请求，但对于tomcat reponse的 gzip数据，仍然是可以正常解压缩处理使用的.#如果一定要生效，可以把源代码中的两个拦截器复制出来自己改一下生效条件让他生效#在FeignContentGzipEncodingAutoConfiguration中使用。作用是根据下面两个条件（请求的http header中的Content-Type和Content-length）把request的header上添加Content-Encoding:gzip,意思是说我请求上来的body值是gzip格式的#但是拦截器本身并不会压缩数据,被调用端也要明白上面两个header的意思能够处理才能够正常工作##配置请求 GZIP 压缩#feign.compression.request.enabled=true##配置压缩支持的 MIME TYPE#feign.compression.request.mime-types=text/xml,application/xml,application/json##配置压缩数据大小的最小阀值，默认 2048=2k#feign.compression.request.min-request-size=1###在FeignAcceptGzipEncodingAutoConfiguration中使用。作用其实只是把request的 httpHeader上添加上Accept-Encoding:gzip，意思是说告诉被请求方我可以解析gzip，你尽管返回gzip格式就是，这个要完全依赖于被调用方对http协议的实现#feign.compression.response.enabled=true#所以，基本可以知道，上面两个配置就是加个header，没有任何卵用，还会引起不必要的问题和以为压缩了，其实并没有。##gzip开启，这个主要是针对tomcat接收端，也就是client或者浏览器，或者是其他微服务过来的调用的请求，支持request和response的gzip压缩，如果request是gzip压缩的，则解压，如果返回值满足下面条件的则压缩了再返回##这个开启不会根据http headerAccept-Encoding:gzip来确定是否返回gzip，所以上面的feign.compression.response.enabled=true开不开都不影响server.compression.enabled=trueserver.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain,application/javascript#默认2kserver.compression.min-response-size=2048#eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/#如果eureka配置了需要密码访问，打开了security.basic.enabled=true, security.user.name=test,security.  user.password=test,则需要配置对应密码才能注册eureka.user=testeureka.pwd=testeureka.client.serviceUrl.defaultZone=http://${eureka.user}:${eureka.pwd}@localhost:8000/eureka/#设置commond对象为default的属性# xxx.default是全局配置#hystrix.command.default.execution.isolation.strategy=SEMAPHOREhystrix.command.default.execution.isolation.strategy=THREAD#这个返回超时时间设置，只有在THREAD模式下可以直接用打断方法主线程对主线程进行回收，并立马把fallback的值返回给前端#而SEMAPHORE模式下，只能先触发fallback方法，但是主线程不会被打断，只能等着robbion的重试时间到达后抛出的异常来对主线程打断进行回收，或者等待主线程正常结束，才把fallback的值返回给前端hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=100000hystrix.command.default.circuitBreaker.requestVolumeThreshold=10# 针对具体的某个commondKey的配置(不能针对commondGroupKey),也不能用HelloRemote#*这种来搞模糊匹配#hystrix.command.HelloRemote#helloHystrixTest(String).circuitBreaker.requestVolumeThreshold=2000hystrix.command.HelloRemote#helloHystrixTest(String).circuitBreaker.requestVolumeThreshold=1# 配置的优先级是#HystrixCommandProperties类中的getProperty方法，可以看到优先级代码如下：#private static HystrixProperty<Integer> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, Integer builderOverrideValue, Integer defaultValue) {#return forInteger()#.add(propertyPrefix + ".command." + key.name() + "." + instanceProperty, builderOverrideValue)#.add(propertyPrefix + ".command.default." + instanceProperty, defaultValue)#.build();#}#上面的代码的意思就是，有指定commandKey的property配置 > feign builder 设置的值 >  command.default的property配置 > HystrixProperty类中的默认值#上面的add方法里面其实是： properties.add(getDynamicProperty(name, defaultValue, getType())); getDynamicProperty这个方法其实就在配置默认值和代码写死默认值之间来做优先级获取，里面是用的Archaius插件来实现#最终是得到一个HystrixChainProperties，按优先级获取值。#Hystrix的动态配置是靠Archaius这个东西来实现的动态配置，在结合springcloud的时候，配置可以配在appliction.properties中，但是如果单独使用的话则需要是classpath下的config.properties或者指定配置文件位置。#官方说明请看：##hystrix的动态配置全部依靠Archaius来管理，可以参考以下官方文档：##https://github.com/Netflix/Hystrix/wiki/Configuration#intro##Hystrix uses Archaius for the default implementation of properties for configuration.###https://github.com/Netflix/archaius/wiki/Getting-Started##There are two ways to get Archaius working out of the box by using a local configuration file to feed dynamic properties to your application.####By default, Archaius will look for a file named “config.properties” on the application’s classpath and read its content as configuration properties. The file can be also in a jar file’s root directory.##In addition, you can define a system property “archaius.configurationSource.additionalUrls” that contains the URL path to a local configuration file. For example, add this to your application start up script##-Darchaius.configurationSource.additionalUrls=file:///apps/myapp/application.properties#可以参考：#https://blog.csdn.net/liuchuanhong1/article/details/73718483#https://www.cnblogs.com/xiong2ge/p/hystrix_faststudy.html#feign 开启hystrix的情况下，最终的方法调用是 HystrixInvocationHandler.invoke方法，可以看到里面实际是把被代理方法生成了一个HystrixCommand对象进行execute同步调用#所以，这种情况下，就算用ThreadPool或者信号量隔离配置，其实tomcat的业务线程还是会阻塞等待返回。#比如a->b,a->c,假如b出问题了，占用a100个线程卡主，则a整体出问题，一样会导致a没有多余的线程调用a->c,除非a线程100，但是b,c每个只给50，这样确实不会影响a太多。但是对于依赖服务的并发水平也会下降。#hystrix的线程隔离无法通过配置刷新实时更新，信号量可以，但是信号量无法做执行命令超时返回。线程池会比信号量更消耗资源#所以目前来说最好的方法就是:#1.如果本服务的大部分方法调用都要依赖远程调用，则线程池设置为和本tomcat线程池数量一样，以达到通用的tps水平#2.如果只有一半以下的方法需要依赖远程调用，则使用tomcat 1/n的线程数，但最小不要超过默认值即可。这样可以给不依赖远程调用的本服务留一部分tomcat业务线程#3.如果很少的方法需要依赖远程调用，则直接采用默认值即可。#最好后面用阿里的哨兵来替代hystrix，然后依赖dashbard的观察来做配置实时刷新。#hystrix的线程和信号量限流都是针对当前单实例进行限流，无法做到集群限流，比如你多部署一个实例，那这个实例仍然会对下游造成多余的流量。#要做到真正的集群限流，需要用阿里的哨兵做集群限流服务器来做。#hystrix官方配置项请看：https://github.com/Netflix/Hystrix/wiki/Configuration#hystrix的线程池隔离的用哪个做key的优先级是：HystrixThreadPoolKey(feign默认为null，除非自己实现配置或者setter) > CommandGroupKey(默认feignClient注解上配置的服务名，不配就是类名)#具体的生成方法是：HystrixThreadPool.Factory.getInstance方法，里面的参数ThreadPoolKey的值在初始化的时候就是按上面优先级来进行初始化的#而如果是使用的Semaphore信号量方式进行隔离的话，key就是完全用的commondKey来进行隔离的，而不是commondGroup，#可以参考源码AbstractCommand.getExecutionSemaphore,可以看到该方法查找有没有信号量隔离是用的commondKey#所以如果用信号量进行隔离的是，只能进行最细粒度方法级也就是commodKey级的隔离。如果想用信号量对整个服务等级进行一个限制，是不行的#hystrix 其实是把一个被调用的方法用command模式包装成一个command对象，里面有一个threadpool和信号量的类变量引用，有一个commandKey为粒度的断路器实例和滑动窗口统计器，以然后执行的时候#源码类HystrixCircuitBreakerImpl#HystrixCircuitBreaker.Factory.getInstance方法会在每个HystrixCommand生成的时候产生一个对应commandKey的断路器实例，#HystrixCircuitBreakerImpl里面有一个针对key的stream统计对象#所以最终断路器统计的粒度和阻止的粒度都是采集的commandKey(也就是方法级的)，commandGroup只会决定threadpoolKey，但是不会决定commandKey#所以加入服务a有接口1，2，1断路了，2还是可以被被调用的，除非2也触发了断路条件。#HystrixComand是用rxjava响应式的方法来进行执行，rxjava是一个更高维度抽象的函数式的响应式变成框架，他把同步异步的发起和结果执行，统已成了发布订阅模式，比如异步中的结果一般用callback回调来#获取，但是rx就统一抽象为observable订阅的方式来执行，而且中间的抽象层次可以组织多次事件结果之间的关系，同步异步线程切换。rx还提供了一个方便的滑动窗口类，hystrix用它来做统计#命令模式最终执行的时候有下面四种方式：#K             value   = command.execute();#// 等价语句：#K             value = command.execute().queue().get();###Future<K>     fValue  = command.queue();#//等价语句：#Future<K>     fValue = command.toObservable().toBlocking().toFuture();###Observable<K> ohValue = command.observe();         //hot observable，立刻订阅，命令立刻执行#//等价语句：#Observable<K> ohValue = command.toObservable().subscribe(subject);##// 上述执行最终实现还是基于`toObservable()`#Observable<K> ocValue = command.toObservable();    //cold observable，延后订阅，订阅发生后，执行才真正执行########### actuator端点配置 ############官网actuator文档 https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/html/production-ready.html#引入依赖spring-boot-starter-actuator开启访问端点，设置actuator暴露的root path和专门的端口(和应用端口区分开)management.context-path=/acmonitormanagement.port=${server.port}#设置了rootpath要重新设置一下health和status路径,目前这两个路径eureka貌似只收集不使用，如果引入spa，目前看spa是在用这个来访问判断其健康与否eureka.instance.health-check-url-path=${management.context-path}/healtheureka.instance.status-page-url-path=${management.context-path}/info#引入依赖spring-boot-starter-security 来保证actuator暴露接口的安全性#端点分为敏感端点和非敏感端点，springboot1.5.2版本默认的非敏感端点只有info和health，这两个访问不需要密码,其它敏感端点需要密码#management.security.enabled=false的情况下, 敏感和非敏感端点访问都不需要密码,，true的时候非敏感端点不需要密码，但是可能暴露的信息会减少management.security.enabled=true#端点安全认证的检查路径，用户和密码security.basic.path=/acmonitorsecurity.basic.enabled=truesecurity.user.name=acadminsecurity.user.password=acadmin123456####################################################################################eureka.instance.metadata-map.user.name=${security.user.name}eureka.instance.metadata-map.user.password=${security.user.password}eureka.instance.metadata-map.management.port=${management.port}eureka.instance.metadata-map.management.context-path=${management.context-path}