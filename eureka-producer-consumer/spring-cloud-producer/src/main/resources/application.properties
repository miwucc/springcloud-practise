spring.application.name=spring-cloud-producer
server.port=9000
eureka.client.serviceUrl.defaultZone=http://test:test@localhost:8000/eureka/
#调用本服务http://localhost:9000/metrics这些关键endpoint的时候可以不用输入密码,http://localhost:9000/health才可以看到更详细的信息
management.security.enabled=false

#如果注册中心开启了服务效验，则需要在连接中配置服务密码
#eureka.client.serviceUrl.defaultZone=<username>:<password>@http://localhost:8000/eureka/,<username>:<password>@http://localhost:8001/eureka/

#增加spring-boot-starter-actuator依赖后可以设置此参数，打开健康检查
#本来默认客户端和注册中心是采用心跳续租来检查是否健康的，但是开启了这个actuator健康检查之后，注册中心会根据客户端的/health端点信息来判断健康特性，
#如果不开启健康检查，只要进程有，每次心跳上报client的状态都是UP
#这样即使心跳有，但是客户端依赖的中间件挂了，注册中心也可知晓这个服务实例挂了.
#这个注释不知道为啥不在eurekaClientConfigBean中找不到，但是这个配置确实是有效的
eureka.client.healthcheck.enabled=false
#默认采用了springboot的根路径，
#eureka.instance.health-check-url=/health
#eureka.instance.status-page-url=/info
#如果不开healthcheck的话，每次上replicator上报的只是自己服务的状态(InstanceInfo中的statue默认为up)，
#获取状态的方法为：org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler.getHealthStatus
# 但是无法知道自己内部某个模块出问题，如果要完全根据actuator中的healthIndicator探测器来判断当前状态，然后最后再在心跳中发给注册中心

#对于开启了actutor健康检查服务上报的服务，如果当时有组件出现错误，当前注册状态为down。
#该注册服务状态同步到springcloudClient端的话，在ribbon的loadbance阶段会认为该实例不可用进行过滤掉，如果过滤后一个可用实例也没有了这个时候远程调用会报错：
#com.netflix.client.ClientException: Load balancer does not have available server for client: serviceName
#所以开启了端点health健康检查的服务要注意，中间某个依赖组件挂了比如redis挂了导致health检查路径出现问题就会导致注册服务状态为down，会导致该服务实例全部的远程调用不通


#actuator是执行器驱动器中枢链接器的意思，主要就是收集了springboot的各种指标和实时运转信息
#可以点开看actuator其中的endpoint包，这个是端点的意思，主要是用来对外暴露http的信息查询端点，比如info，metric，helth，每个相应的类就叫xxxEndpoint
#下面有health，metric，info等包，就是对应信息的收集类health是健康信息类，每个都叫xxxHealthIndicator(健康指标)，用于手机系统类各种组件的健康信息,比如redis,rabbit等
#info下面的就叫xxxContributor(意思就是某类信息撰稿人),metrics下面的各种组件的累计指标信息和可用的相应的工具组件，比如Gauge


#所有eureka.instance开头的配置叫做服务实例配置，相关类可以看EurekaInstanceConfigBean,实例配置有很大一部分是配置元信息最后会在注册的时候发送给注册中心
#注册实例ID,用于区分同一服务不同实例。默认是采取主机名+端口,比如：localhost:spring-cloud-producer:9000
eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${server.port}


#注册上来的服务的续租间隔时间，默认30s，意思是每30s需要客户端服务注册到注册中心来维持心跳，在第一次注册的时候会把这个参数下放给服务提供者
#eureka.instance.lease-renewal-interval-in-seconds=30
#告诉注册中心,超过多少秒没有续租则认为服务时效超时，默认90s
#eureka.instance.lease-expiration-duration-in-seconds=90
#发送心跳的操作是一个异步任务，如果发送失败，则以2的指数形式延长重试的时间，直到达到eureka.instance.leaseRenewalIntervalInSeconds * eureka.client.heartbeatExecutorExponentialBackOffBound这个上限,之后一直以这个上限值作为重试间隔，直至重新连接到Eureka server，并且重新尝试连接到Eureka server的次数是不受限制的。

#是否注册到eureka,默认为true
eureka.client.register-with-eureka=true
#lient向Eureka server发送心跳和更新注册信息是不相同的，InstanceInfo也以固定的频率发送到Eureka server，这些信息在Eureka client启动后的40s（通过eureka.client.initialInstanceInfoReplicationIntervalSeconds配置）首次发送，之后每隔30s(通过eureka.client.instanceInfoReplicationIntervalSeconds配置)检查刷新一次本地服务状态statusInfo。
#这个更新里面会根据当前org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler.getStatus方法获取健康检查结果得到实例的真实健康状态(UP/DOWN等等)并上报到注册中心进行覆盖本地状态信息，定时任务类是InstanceInfoReplicator，然后renew心跳续租的时候会把这个状态报给注册中心
#最终调用健康检查的健康状态的收集类是CompositeHealthIndicator，这个是把所有的健康检查端点都集成到里面了
eureka.client.initial-instance-info-replication-interval-seconds=40
eureka.client.instance-info-replication-interval-seconds=30
#DiscoveryClient作为springcloud的超类，里面有有作为服务客户端启动定时任务的方法：
#com.netflix.discovery.DiscoveryClient.initScheduledTasks
#该方法会创建很多个定时任务，其中有一个叫InstanceInfoReplicator的定时任务，也有一个叫renew的定时任务，renew负责向注册中心续租和上报刷新服务的状态(up/down),而Replicator定时负责第一次向注册中心register，然后同时后面
#每eureka.client.instance-info-replication-interval-seconds时间通过EurekaHealthCheckHandler.getStatus方法刷新一下本地服务状态。然后renew续租的时候，会把当前状态带上发送给注册中心。
#客户端上传的状态，注册中心只是做保留和给使用者列表下发，但是ribbon如果发现得到的列表中状态不是up的话，则不会做请求转发到该实例上去。




#是否打开自我保护模式，默认是true,如果是false则一旦触发心跳不稳定状态则会直接移除服务列表,建议设置为true
#在eruka管理界面可以看到有Renews threshold和Renews(last min)两个显示，分别代表预期每分钟当前注册服务的续租总次数，和
#实际最近1分钟续租的总次数，如果Renews(last min)<Renews threshold,则会有大大的红字提示出现在界面中，提示触发了保护模式
#EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT.
# RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
# 保护模式的意思是注册中心和某些服务之间心跳不稳定，但是注册中心不会把这些服务从服务列表中移除。
# 因为一旦触发保护状态，如果把某个服务实例移除的话，但可能只是该服务实例和注册中心之间网络不好，但是和服务被调用者之间是好的，一旦移除直接就不可用了
# Renews threshold =服务实例数*2(意思是默认30s续租一次)*0.85(eureka.server.renewal-percent-threshold可配置，默认0.85)
# eureka.server.enable-self-preservation=true

# 所有配置项请参考:EurekaServerConfigBean类
# eureka注册中心对客户端的所有rest请求处理请参考类:
#
#
#EurekaAutoServiceRegistration监听了spring容器的关闭事件，可以看方法org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration.onApplicationEvent(org.springframework.context.event.ContextClosedEvent)
#里面关闭了当前事件，最后调用的是com.netflix.discovery.DiscoveryClient.unregister方法
#
#
#
