spring.application.name=spring-cloud-eureka

server.port=8000
#禁止自己作为客户端注册到自己
eureka.client.register-with-eureka=false
#禁止自己作为客户端拉取服务列表
eureka.client.fetch-registry=false

#以上两项如果打开的话会在后台看到自己注册成了一个服务。

#客户端要访问的eureka地址
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/
#启动后访问localhost:8000就是eureka后台了

#开启注册权限认证，必须要引入
#<dependency>
#<groupId>org.springframework.boot</groupId>
#<artifactId>spring-boot-starter-security</artifactId>
#</dependency>
#开启后注册上来的客户端必须配置用户名密码才可以访问 eureka.client.serviceUrl.defaultZone=<username>:<password>@http://localhost:8000/eureka/
#或者是配置eureka.user，eureka.pwd
#注意，只要你引入了spring-boot-starter-security依赖默认就会开启安全认证，并且会默认打开csrf防御，这个时候需要显示的把安全配置配完，如下
security.basic.enabled=false
security.user.name="test"
security.user.password="test"

#注册上来的服务的续租间隔时间，默认30s，意思是每30s需要客户端服务注册到注册中心来维持心跳，在第一次注册的时候会把这个参数下放给服务提供者
#eureka.instance.lease-renewal-interval-in-seconds=30 注意这个属性是配置在client端的而不是注册中心，是作为注册信息发给注册中心的,源码类DisCoveryClient.initSchedule
#超过多少秒没有续租则认为服务时效超时，默认90s
#eureka.instance.lease-expiration-duration-in-seconds=90  注意这个属性是配置在client端的而不是注册中心，是作为注册信息发给注册中心的,源码类DisCoveryClient.initSchedule
#在eruka管理界面可以看到有Renews threshold和Renews(last min)两个显示，分别代表预期每分钟当前注册服务的续租总次数，和
#实际最好1分钟续租的总次数，如果Renews(last min)<Renews threshold,则会有大大的红字提示出现在界面中，提示触发了保护模式
#EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT.
# RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
# 保护模式的意思是注册中心和某些服务之间心跳不稳定，但是注册中心不会把这些服务从服务列表中移除。
# 因为一旦触发保护状态，如果把某个服务实例移除的话，但可能只是该服务实例和注册中心之间网络不好，但是和服务被调用者之间是好的，一旦移除直接就不可用了
# Renews threshold =服务实例数*2(意思是默认30s续租一次)*0.85(eureka.server.renewal-percent-threshold可配置，默认0.85)
#是否打开自我保护模式，默认是true,如果是false则一旦触发心跳不稳定状态则会直接移除服务列表,建议设置为true
# eureka.server.enable-self-preservation=true

# 所有配置项请参考:EurekaServerConfigBean类
# eureka注册中心对客户端的所有rest请求处理请参考:com.netflix.eureka.resources包下面
# 比如ApplicationResource的addInstance方法就是收instance服务实例注册的方法
# 每次客户端注册到注册中心的时候，有一个参数叫isReplication，这个就可以告知是普通服务，还是用于复制的注册中心服务。可以参看上面写的这个类的addInstance
# 方法，在注册的时候，会先效验，然后调用publishEvent传播事件出去，然后真正调用register方法把服务注册在一个map<key服务名字,map<key实例ID,实例元信息>>的数据结构中
#
#


